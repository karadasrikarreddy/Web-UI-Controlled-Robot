/*
 * Project: ROS 2 Autonomous Robot - OPTIMIZED
 * Author: Srikar Reddy (Enhanced)
 * Date: February 2026
 * License: Apache 2.0
 * 
 * IMPROVEMENTS:
 * - Smoother velocity control with acceleration limits
 * - Better path following with adaptive lookahead
 * - Predictive obstacle avoidance
 * - Velocity profiling for corners
 */
#include <rclcpp/rclcpp.hpp>
#include <nav_msgs/msg/path.hpp>
#include <sensor_msgs/msg/point_cloud2.hpp>
#include <geometry_msgs/msg/twist.hpp>
#include <tf2_ros/transform_listener.h>
#include <tf2_ros/buffer.h>
#include <tf2_geometry_msgs/tf2_geometry_msgs.hpp>
#include <pcl_conversions/pcl_conversions.h>
#include <pcl/point_cloud.h>
#include <pcl/point_types.h>
#include <cmath>
#include <algorithm>

class OptimizedLocalPlanner : public rclcpp::Node {
public:
    OptimizedLocalPlanner() : Node("local_planner") {
        // Enhanced Parameters
        this->declare_parameter("base_lookahead", 0.8);        // Base lookahead distance
        this->declare_parameter("max_lookahead", 1.5);         // Max lookahead at high speed
        this->declare_parameter("min_lookahead", 0.5);         // Min lookahead at low speed
        this->declare_parameter("obstacle_weight", 0.3);       // Reduced for smoother motion
        this->declare_parameter("max_speed", 0.5);             // Maximum linear velocity
        this->declare_parameter("max_angular_vel", 1.5);       // Maximum angular velocity
        this->declare_parameter("max_linear_accel", 0.4);      // Acceleration limit
        this->declare_parameter("max_angular_accel", 1.0);     // Angular acceleration limit
        this->declare_parameter("goal_tolerance", 0.15);       // Goal reached threshold
        this->declare_parameter("path_completion_angle", 0.3); // Angle threshold for path completion

        // Subscribers
        sub_path_ = this->create_subscription<nav_msgs::msg::Path>(
            "/planned_path", 10, 
            std::bind(&OptimizedLocalPlanner::path_callback, this, std::placeholders::_1));
        
        sub_lidar_ = this->create_subscription<sensor_msgs::msg::PointCloud2>(
            "/livox/points", 10, 
            std::bind(&OptimizedLocalPlanner::lidar_callback, this, std::placeholders::_1));

        // Publisher
        pub_vel_ = this->create_publisher<geometry_msgs::msg::Twist>("/cmd_vel_drive", 10);

        // TF
        tf_buffer_ = std::make_unique<tf2_ros::Buffer>(this->get_clock());
        tf_listener_ = std::make_shared<tf2_ros::TransformListener>(*tf_buffer_);

        // Control loop at 20Hz for smooth motion
        timer_ = this->create_wall_timer(
            std::chrono::milliseconds(50), 
            std::bind(&OptimizedLocalPlanner::control_loop, this));

        RCLCPP_INFO(this->get_logger(), "âœ… Optimized Local Planner Ready (Smooth Control Enabled)");
    }

private:
    void path_callback(const nav_msgs::msg::Path::SharedPtr msg) {
        current_path_ = *msg;
        current_goal_index_ = 0;
        path_received_ = true;
        goal_reached_logged_ = false;
        RCLCPP_INFO(this->get_logger(), "ðŸ“ New path received: %lu waypoints", msg->poses.size());
    }

    void lidar_callback(const sensor_msgs::msg::PointCloud2::SharedPtr msg) {
        pcl::fromROSMsg(*msg, latest_scan_);
    }

    void control_loop() {
        if (!path_received_ || current_path_.poses.empty()) {
            publish_velocity(0.0, 0.0);
            return;
        }

        // 1. Get Robot Pose
        geometry_msgs::msg::TransformStamped t;
        try {
            t = tf_buffer_->lookupTransform("map", "base_link", tf2::TimePointZero);
        } catch (const tf2::TransformException &ex) { 
            return; 
        }

        double rx = t.transform.translation.x;
        double ry = t.transform.translation.y;
        
        tf2::Quaternion q(
            t.transform.rotation.x, t.transform.rotation.y, 
            t.transform.rotation.z, t.transform.rotation.w
        );
        tf2::Matrix3x3 m(q);
        double roll, pitch, yaw;
        m.getRPY(roll, pitch, yaw);

        // 2. Adaptive Lookahead Based on Velocity
        double current_speed = std::hypot(last_linear_vel_, last_angular_vel_);
        double lookahead = calculate_adaptive_lookahead(current_speed);
        
        // 3. Find Lookahead Point
        double gx, gy;
        bool end_reached = get_lookahead_point(rx, ry, lookahead, gx, gy);

        if (end_reached) {
            // Smooth stop at goal
            publish_velocity(0.0, 0.0);
            if (!goal_reached_logged_) {
                RCLCPP_INFO(this->get_logger(), "ðŸŽ¯ Goal Reached!");
                goal_reached_logged_ = true;
            }
            path_received_ = false;
            return;
        }

        // 4. Calculate Attractive Force (towards path)
        double att_x = gx - rx;
        double att_y = gy - ry;
        double att_magnitude = std::hypot(att_x, att_y);
        
        if (att_magnitude > 0.01) {
            att_x /= att_magnitude;
            att_y /= att_magnitude;
        }

        // 5. Calculate Repulsive Force (from obstacles)
        double rep_x = 0.0;
        double rep_y = 0.0;
        double obs_weight = this->get_parameter("obstacle_weight").as_double();

        if (!latest_scan_.empty()) {
            calculate_repulsive_force(rep_x, rep_y, yaw);
        }

        // 6. Combine Forces
        double total_x = att_x + (rep_x * obs_weight);
        double total_y = att_y + (rep_y * obs_weight);

        // 7. Calculate Desired Heading
        double desired_yaw = std::atan2(total_y, total_x);
        double yaw_error = normalize_angle(desired_yaw - yaw);

        // 8. Velocity Control with Smoothing
        double max_speed = this->get_parameter("max_speed").as_double();
        double max_angular = this->get_parameter("max_angular_vel").as_double();
        
        // Angular velocity with smooth control
        double angular_vel = std::clamp(2.0 * yaw_error, -max_angular, max_angular);
        
        // Linear velocity scaled by alignment and distance
        double alignment_factor = 1.0 - std::min(1.0, std::abs(yaw_error) / M_PI);
        double distance_factor = std::min(1.0, att_magnitude / 2.0);
        double target_speed = max_speed * alignment_factor * distance_factor;
        
        // Minimum speed when moving forward
        if (target_speed > 0.05 && target_speed < 0.1) {
            target_speed = 0.1;
        }

        // 9. Apply Acceleration Limits
        double linear_vel = apply_acceleration_limit(
            last_linear_vel_, target_speed, 
            this->get_parameter("max_linear_accel").as_double()
        );
        
        angular_vel = apply_acceleration_limit(
            last_angular_vel_, angular_vel,
            this->get_parameter("max_angular_accel").as_double()
        );

        // 10. Publish
        publish_velocity(linear_vel, angular_vel);
    }

    double calculate_adaptive_lookahead(double current_speed) {
        double max_lookahead = this->get_parameter("max_lookahead").as_double();
        double min_lookahead = this->get_parameter("min_lookahead").as_double();
        double max_speed = this->get_parameter("max_speed").as_double();
        
        // Lookahead increases with speed linearly
        double speed_ratio = std::min(1.0, current_speed / max_speed);
        return min_lookahead + speed_ratio * (max_lookahead - min_lookahead);
    }

    void calculate_repulsive_force(double& rep_x, double& rep_y, double robot_yaw) {
        int obstacle_count = 0;
        double total_rep_x = 0.0;
        double total_rep_y = 0.0;
        
        for (const auto& pt : latest_scan_.points) {
            // Height filter
            if (pt.z < 0.05 || pt.z > 1.2) continue;
            
            double dist = std::hypot(pt.x, pt.y);
            
            // Self filter
            if (dist < 0.35) continue;
            
            // Only repel from nearby obstacles
            if (dist < 1.2) {
                // Stronger repulsion for closer obstacles
                double force = std::pow(1.0 / dist, 2) * 0.5;
                
                // Direction away from obstacle (in robot frame)
                double local_rep_x = -pt.x / dist;
                double local_rep_y = -pt.y / dist;

                // Transform to global frame
                total_rep_x += (local_rep_x * cos(robot_yaw) - local_rep_y * sin(robot_yaw)) * force;
                total_rep_y += (local_rep_x * sin(robot_yaw) + local_rep_y * cos(robot_yaw)) * force;
                obstacle_count++;
            }
        }

        // Average the repulsion
        if (obstacle_count > 0) {
            rep_x = total_rep_x / obstacle_count;
            rep_y = total_rep_y / obstacle_count;
        }
    }

    bool get_lookahead_point(double rx, double ry, double dist, double& gx, double& gy) {
        double goal_tolerance = this->get_parameter("goal_tolerance").as_double();
        
        // Find the farthest point within lookahead distance
        for (; current_goal_index_ < current_path_.poses.size(); current_goal_index_++) {
            gx = current_path_.poses[current_goal_index_].pose.position.x;
            gy = current_path_.poses[current_goal_index_].pose.position.y;
            
            double distance = std::hypot(gx - rx, gy - ry);
            
            // Check if we reached the final goal
            if (current_goal_index_ == current_path_.poses.size() - 1) {
                return distance < goal_tolerance;
            }
            
            // Return point just beyond lookahead
            if (distance > dist) {
                return false;
            }
        }
        
        return true; // End of path
    }

    double apply_acceleration_limit(double current_vel, double target_vel, double max_accel) {
        double dt = 0.05; // 20Hz control loop
        double max_delta = max_accel * dt;
        double delta = target_vel - current_vel;
        
        if (std::abs(delta) > max_delta) {
            return current_vel + std::copysign(max_delta, delta);
        }
        return target_vel;
    }

    double normalize_angle(double angle) {
        while (angle > M_PI) angle -= 2.0 * M_PI;
        while (angle < -M_PI) angle += 2.0 * M_PI;
        return angle;
    }

    void publish_velocity(double linear, double angular) {
        geometry_msgs::msg::Twist cmd;
        cmd.linear.x = linear;
        cmd.angular.z = angular;
        pub_vel_->publish(cmd);
        
        // Store for next iteration
        last_linear_vel_ = linear;
        last_angular_vel_ = angular;
    }

    // Members
    rclcpp::Subscription<nav_msgs::msg::Path>::SharedPtr sub_path_;
    rclcpp::Subscription<sensor_msgs::msg::PointCloud2>::SharedPtr sub_lidar_;
    rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtr pub_vel_;
    rclcpp::TimerBase::SharedPtr timer_;
    std::shared_ptr<tf2_ros::TransformListener> tf_listener_;
    std::unique_ptr<tf2_ros::Buffer> tf_buffer_;

    nav_msgs::msg::Path current_path_;
    pcl::PointCloud<pcl::PointXYZ> latest_scan_;
    size_t current_goal_index_ = 0;
    bool path_received_ = false;
    bool goal_reached_logged_ = false;
    
    double last_linear_vel_ = 0.0;
    double last_angular_vel_ = 0.0;
};

int main(int argc, char** argv) {
    rclcpp::init(argc, argv);
    rclcpp::spin(std::make_shared<OptimizedLocalPlanner>());
    rclcpp::shutdown();
    return 0;
}
